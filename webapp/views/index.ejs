<!doctype html>
<html lang="en">
<head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Bootstrap demo</title>
        <link href="/static/js/css/bootstrap.min.css" rel="stylesheet">
    </head>
    <body> 
        <script src="/static/js/js/bootstrap.bundle.min.js"></script>
 
        <button id="start">Start</button>
        <button id="stop">Stop</button>     
        <br>
        <br>
        <audio id="player" controls></audio>
        <br>
        <!--<a id="download">Download</a>-->

        <script>

            const startButton = document.getElementById('start');
            const stopButton = document.getElementById('stop');
            const player = document.getElementById('player');
            //const downloadLink = document.getElementById('download');

            const handleSuccess = async function(stream) {

                var recordedChunks = [];
                const options = { mimeType: 'audio/webm' };
                const mediaRecorder = new MediaRecorder(stream, options);

                // Reset recorded data when media record starts.
                mediaRecorder.addEventListener('start', function() {
                    recordedChunks = [];
                });

                // While recorder is active, add recorded data to an array.
                mediaRecorder.addEventListener('dataavailable', function(e) {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                });

                /* 
                When the recorder stops, encode the data and send it to the media conversion endpoint.
                The browser only supports .webm encoding, but we can't use the .webm format with HuggingFace models.
                */
                mediaRecorder.addEventListener('stop', async function() {

                    const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });

                    if(audioBlob.size < 1000000) {

                        // Send Blob as multipart/formdata.
                        const convertServiceFormData = new FormData();
                        convertServiceFormData.append('recording', audioBlob, 'recording.webm');

                        // First, we convert the media, then we send the converted media to the Flask application to get a reply.
                        const response = await fetch('http://localhost:3000/convert', {
                            method: 'POST',
                            body: convertServiceFormData,
                        }).then(function(response) {

                            if (!response.ok) {
                                throw new Error('Response to Conversion Service not OK');
                            }
                            return response.blob();

                        }).then(async function(convertedBlob) {
   
                            /*
                            const urlSource = URL.createObjectURL(convertedBlob);
                            downloadLink.href = urlSource;
                            downloadLink.download = 'converted.wav';
                            player.src = urlSource;*/

                            const flaskAppFormData = new FormData();
                            flaskAppFormData.append('converted', convertedBlob, 'converted.wav');

                            // Send the converted media to the Flask application and get the reply.
                            const response = await fetch('http://localhost:5050/reply', {
                                method: 'POST',
                                body: flaskAppFormData,
                            }).then(function(response) {

                                if (!response.ok) {
                                    throw new Error('Reply Service response not OK');
                                }
                                return response.json();

                            }).then(function(data){

                                const dataUrl = 'data:audio/wav;base64,' + data['base64_wav']

                                fetch(dataUrl)
                                .then(result => result.blob())
                                .then(function(replyBlob){

                                    const urlSource = URL.createObjectURL(replyBlob);
                                    player.src = urlSource;
                                    player.play

                                })

                            }).catch(function(error){
                                console.error('Problem with your fetch operation to Reply Service:', error);
                            });

                        }).catch(function(error) {
                            console.error('Problem with your fetch operation to Conversion Service:', error);
                        });

                    } else {
                        alert("Recording size limit exceeded.");
                    }

                });

                // TODO: Consider having the system listen continuously instead of stopping & starting.
                startButton.addEventListener('click', function() {
                    mediaRecorder.start();
                });

                stopButton.addEventListener('click', function() {
                    mediaRecorder.stop();           
                });
 
            };

            navigator.mediaDevices
            .getUserMedia({audio: true, video: false})
            .then(handleSuccess);

        </script>
    </body>
</html>