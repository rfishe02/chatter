<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Bootstrap demo</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    </head>
    <body> 
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>
 
        <button id="start">Start</button>
        <button id="stop">Stop</button>     
        <br>
        <br>
        <audio id="player" controls></audio>

        <!-- Access the microphone interactively https://web.dev/media-recording-audio/#save-the-data-from-the-microphone -->

        <script>

            const startButton = document.getElementById('start');
            const stopButton = document.getElementById('stop');
            const player = document.getElementById('player');

            const handleSuccess = async function(stream) {

              var recordedChunks = [];
              const options = { mimeType: 'audio/webm' };
              const mediaRecorder = new MediaRecorder(stream, options);

              // Reset recorded data when media record starts.
              mediaRecorder.addEventListener('start', function() {
                recordedChunks = [];
              });

              // While recorder is active, add recorded data to an array.
              mediaRecorder.addEventListener('dataavailable', function(e) {
                if (e.data.size > 0) recordedChunks.push(e.data);
              });

              /* When the recorder stops, encode the data and send it to the media conversion endpoint.
                 The browser only supports .webm encoding, but we can't use the .webm format with HuggingFace models.
              */
              mediaRecorder.addEventListener('stop', async function() {

                // We can send Blob as multipart/formdata.
                const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                const formData = new FormData();
                formData.append('recording', audioBlob, 'recording.webm');

                const response = await fetch('http://localhost:3000/convert', {
                  method: 'POST',
                  body: formData,
                })
                .then((response) => {
                  if (!response.ok) {
                    throw new Error('Network response was not OK');
                  }
                  return response.blob();
                })
                .then((data) => {
   
                  source = URL.createObjectURL(data);
                  player.src = source;

                })
                .catch((error) => {
                  console.error('There has been a problem with your fetch operation:', error);
                });

              });

              startButton.addEventListener('click', function() {
                mediaRecorder.start();
              });

              stopButton.addEventListener('click', function() {
                mediaRecorder.stop();           
              });
 
            };

            navigator.mediaDevices
            .getUserMedia({audio: true, video: false})
            .then(handleSuccess);

        </script>
    </body>
</html>