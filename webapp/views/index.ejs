<!doctype html>
<html lang="en">
<head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Bootstrap demo</title>
        <link href="/static/js/css/bootstrap.min.css" rel="stylesheet">
    </head>
    <body> 
        <script src="/static/js/js/bootstrap.bundle.min.js"></script>
 
        <div class="container">

            <div class="row mb-3 justify-content-center" style="padding-top: 100px;">
                <div class="col-2">
                    <button id="speak" type="button" class="btn btn-light w-100">Hold to Talk</button>
                </div>
            </div>

            <div class="row justify-content-center">
                <div class="col-3">
                    <audio id="player" controls></audio>
                </div>
            </div>

        </div>

        <script>

            const pptButton = document.getElementById('speak');
            const player = document.getElementById('player');

            var conversation = [];

            const handleSuccess = async function(stream) {

                var recordedChunks = [];
                const options = { mimeType: 'audio/webm' };
                const mediaRecorder = new MediaRecorder(stream, options);

                // Reset recorded data when media record starts.
                mediaRecorder.addEventListener('start', function() {
                    recordedChunks = [];
                });

                // While recorder is active, add recorded data to an array.
                mediaRecorder.addEventListener('dataavailable', function(e) {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                });

                /* 
                When the recorder stops, encode the data and send it to the media conversion endpoint.
                The browser only supports .webm encoding, but we can't use the .webm format with HuggingFace models.
                */
                mediaRecorder.addEventListener('stop', async function() {

                    const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });

                    if(audioBlob.size < 1000000) {

                        // Send Blob as multipart/formdata.
                        const convertServiceFormData = new FormData();
                        convertServiceFormData.append('recording', audioBlob, 'recording.webm');

                        // First, we convert the media, then we send the converted media to the Flask application to get a reply.
                        const response = await fetch('http://localhost:3000/convert', {
                            method: 'POST',
                            body: convertServiceFormData,
                        }).then(function(response) {

                            if (!response.ok) {
                                throw new Error('Response to Conversion Service not OK');
                            }
                            return response.blob();

                        }).then(async function(convertedBlob) {
   
                            const flaskAppFormData = new FormData();
                            flaskAppFormData.append('converted', convertedBlob, 'converted.wav');

                            if(conversation.length > 0) {
                                const previous_conversation = conversation.slice(-2).join('</s> <s>') + '</s> <s>'
                                console.log(previous_conversation)
                                flaskAppFormData.append('previous_txt',previous_conversation);
                            }

                            // Send the converted media to the Flask application and get the reply.
                            const response = await fetch('http://localhost:5050/reply', {
                                method: 'POST',
                                body: flaskAppFormData,
                            }).then(function(response) {

                                if (!response.ok) {
                                    throw new Error('Reply Service response not OK');
                                }
                                return response.json();

                            }).then(function(data){

                                conversation.push(data["asr"])
                                conversation.push(data["txt_reply"])

                                const dataUrl = 'data:audio/wav;base64,' + data['base64_wav']

                                fetch(dataUrl)
                                .then(result => result.blob())
                                .then(function(replyBlob){

                                    const urlSource = URL.createObjectURL(replyBlob);
                                    player.src = urlSource;
                                    player.play()

                                })

                            }).catch(function(error){
                                console.error('Problem with your fetch operation to Reply Service:', error);
                            });

                        }).catch(function(error) {
                            console.error('Problem with your fetch operation to Conversion Service:', error);
                        });

                    } else {
                        alert("Recording size limit exceeded.");
                    }

                });

                // TODO: Consider having the system listen continuously instead of stopping & starting.
                pptButton.addEventListener('mousedown', function() {
                    mediaRecorder.start();

                    pptButton.classList.add('btn-dark');
                    //pptButton.classList.remove('btn-light');

                });

                pptButton.addEventListener('mouseup', function() {
                    mediaRecorder.stop();
                    
                    //pptButton.classList.add('btn-light');
                    pptButton.classList.remove('btn-dark');
                });
 
            };

            navigator.mediaDevices
            .getUserMedia({audio: true, video: false})
            .then(handleSuccess);

        </script>
    </body>
</html>